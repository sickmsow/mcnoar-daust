<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>MCNOAR — Oldest Human Skull AR</title>
    <!-- A-Frame -->
    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
    <!-- MindAR -->
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.2/dist/mindar-image-aframe.prod.js"></script>
    <!-- Three.js for free view -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- GLTFLoader -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/loaders/GLTFLoader.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, sans-serif;
        background: #000;
        overflow: hidden;
        width: 100vw;
        height: 100vh;
      }
      .ui {
        position: fixed;
        top: 12px;
        left: 12px;
        right: 12px;
        display: flex;
        justify-content: space-between;
        gap: 12px;
        z-index: 100;
        pointer-events: none;
      }
      .ui .card {
        pointer-events: auto;
        background: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(10px);
        padding: 10px 16px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
        font-size: 13px;
        color: #fff;
      }
      .center-hint {
        position: fixed;
        bottom: 200px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 100;
        pointer-events: none;
        background: rgba(255, 255, 255, 0.95);
        color: #222;
        padding: 10px 20px;
        border-radius: 999px;
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.2);
        font-size: 14px;
        text-align: center;
        white-space: nowrap;
        transition: opacity 0.3s;
      }
      .mode-toggle {
        position: fixed;
        bottom: 140px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 100;
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        color: white;
        border: none;
        padding: 14px 32px;
        border-radius: 50px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        box-shadow: 0 8px 24px rgba(240, 147, 251, 0.4);
        transition: all 0.3s ease;
        pointer-events: auto;
      }
      .mode-toggle:active {
        transform: translateX(-50%) scale(0.95);
      }
      .info-button {
        position: fixed;
        bottom: 60px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 100;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 16px 40px;
        border-radius: 50px;
        font-size: 18px;
        font-weight: 600;
        cursor: pointer;
        box-shadow: 0 8px 24px rgba(102, 126, 234, 0.4);
        transition: all 0.3s ease;
        pointer-events: auto;
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .info-button:active {
        transform: translateX(-50%) scale(0.95);
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
      }
      .info-button svg {
        width: 24px;
        height: 24px;
      }
      .controls-hint {
        position: fixed;
        top: 80px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 100;
        background: rgba(0, 0, 0, 0.8);
        color: #fff;
        padding: 12px 20px;
        border-radius: 12px;
        font-size: 12px;
        text-align: center;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s;
      }
      .controls-hint.show {
        opacity: 1;
      }
      /* Blur overlay for free view mode */
      .blur-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(8px);
        z-index: 2;
        display: none;
        pointer-events: none;
      }
      .blur-overlay.active {
        display: block;
      }
      a-scene {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
      }
      /* Free view container */
      .free-view-container {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 90%;
        height: 60%;
        z-index: 3;
        display: none;
        pointer-events: auto;
        background: rgba(20, 20, 30, 0.95);
        border-radius: 20px;
        border: 2px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        overflow: hidden;
      }
      .free-view-container.active {
        display: block;
      }
      #freeViewCanvas {
        width: 100%;
        height: 100%;
        display: block;
        touch-action: none;
      }
    </style>
  </head>
  <body>
    <div class="ui">
      <div class="card">
        <strong>Oldest Human Skull</strong><br />
        <span id="modeText">Anchored Mode</span>
      </div>
      <div class="card" id="status">Status: <strong>Scanning</strong></div>
    </div>
    <div class="center-hint" id="hint">Point camera at target image...</div>
    <div class="controls-hint" id="controlsHint">
      Pinch to scale • Drag to rotate
    </div>
    
    <button class="mode-toggle" id="modeToggle" style="display: none;">
      Switch to Free View
    </button>
    
    <button class="info-button" onclick="window.location.href='skull-info.html'">
      <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
      </svg>
      Learn More
    </button>
    
    <!-- Blur overlay -->
    <div class="blur-overlay" id="blurOverlay"></div>
    
    <!-- Free view container with Three.js canvas -->
    <div class="free-view-container" id="freeViewContainer">
      <canvas id="freeViewCanvas"></canvas>
    </div>
    
    <!-- Main AR Scene -->
    <a-scene
      id="mainScene"
      mindar-image="imageTargetSrc: assets/demo.mind; autoStart: true; uiLoading: no; uiError: no; uiScanning: no;"
      color-space="sRGB"
      renderer="colorManagement: true; physicallyCorrectLights: true; alpha: true;"
      vr-mode-ui="enabled: false"
      device-orientation-permission-ui="enabled: false"
      embedded
    >
      
      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>
      
      <!-- Anchored Mode - Target based (scaled down for mobile) -->
      <a-entity mindar-image-target="targetIndex: 0" id="target">
        <a-entity id="skullAnchor">
          <a-gltf-model
            id="skullModel"
            src="assets/skull.glb"
            position="0 0 0"
            scale="0.05 0.05 0.05"
            rotation="0 0 0"
            animation="property: rotation; to: 0 360 0; loop: true; dur: 8000; easing: linear"
          ></a-gltf-model>
          
          <!-- Lighting for the skull -->
          <a-light type="point" intensity="1.2" position="0 0.5 0.5" color="#fff"></a-light>
          <a-light type="ambient" intensity="0.6" color="#fff"></a-light>
        </a-entity>
      </a-entity>
    </a-scene>
    
    <script>
      const target = document.querySelector("#target");
      const statusEl = document.querySelector("#status");
      const hintEl = document.querySelector("#hint");
      const modeToggle = document.querySelector("#modeToggle");
      const modeText = document.querySelector("#modeText");
      const controlsHint = document.querySelector("#controlsHint");
      const skullAnchor = document.querySelector("#skullAnchor");
      const mainScene = document.querySelector("#mainScene");
      const freeViewContainer = document.querySelector("#freeViewContainer");
      const freeViewCanvas = document.querySelector("#freeViewCanvas");
      const blurOverlay = document.querySelector("#blurOverlay");
      
      let isAnchoredMode = true;
      let targetDetected = false;
      
      // Three.js setup for free view
      let threeScene, threeCamera, threeRenderer, skullMesh;
      let currentScale = 1;
      let currentRotationX = 0;
      let currentRotationY = 0;
      
      function initThreeJS() {
        // Scene
        threeScene = new THREE.Scene();
        threeScene.background = new THREE.Color(0x14141e);
        
        // Camera
        threeCamera = new THREE.PerspectiveCamera(
          45,
          freeViewCanvas.clientWidth / freeViewCanvas.clientHeight,
          0.1,
          1000
        );
        threeCamera.position.z = 3;
        
        // Renderer
        threeRenderer = new THREE.WebGLRenderer({
          canvas: freeViewCanvas,
          antialias: true,
          alpha: true
        });
        threeRenderer.setSize(freeViewCanvas.clientWidth, freeViewCanvas.clientHeight);
        threeRenderer.setPixelRatio(window.devicePixelRatio);
        
        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        threeScene.add(ambientLight);
        
        const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight1.position.set(2, 2, 2);
        threeScene.add(directionalLight1);
        
        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight2.position.set(-2, 2, -2);
        threeScene.add(directionalLight2);
        
        const directionalLight3 = new THREE.DirectionalLight(0xffffff, 0.3);
        directionalLight3.position.set(0, -2, 0);
        threeScene.add(directionalLight3);
        
        // Load skull model
        const loader = new THREE.GLTFLoader();
        loader.load(
          'assets/skull.glb',
          (gltf) => {
            skullMesh = gltf.scene;
            skullMesh.scale.set(1, 1, 1);
            threeScene.add(skullMesh);
            console.log('Skull model loaded in Three.js');
          },
          (progress) => {
            console.log('Loading:', (progress.loaded / progress.total * 100) + '%');
          },
          (error) => {
            console.error('Error loading skull model:', error);
          }
        );
        
        // Handle window resize
        window.addEventListener('resize', onWindowResize, false);
        
        // Start animation loop
        animate();
      }
      
      function animate() {
        requestAnimationFrame(animate);
        if (!isAnchoredMode && skullMesh) {
          threeRenderer.render(threeScene, threeCamera);
        }
      }
      
      function onWindowResize() {
        if (freeViewCanvas.clientWidth > 0 && freeViewCanvas.clientHeight > 0) {
          threeCamera.aspect = freeViewCanvas.clientWidth / freeViewCanvas.clientHeight;
          threeCamera.updateProjectionMatrix();
          threeRenderer.setSize(freeViewCanvas.clientWidth, freeViewCanvas.clientHeight);
        }
      }
      
      // Initialize Three.js when page loads
      window.addEventListener('load', () => {
        initThreeJS();
      });
      
      // Touch interaction variables
      let touchStartX = 0;
      let touchStartY = 0;
      let pinchStartDistance = 0;
      
      // Target found
      target.addEventListener("targetFound", () => {
        targetDetected = true;
        statusEl.innerHTML = "Status: <strong style='color: #4ade80'>Detected ✓</strong>";
        hintEl.innerText = "Skull anchored to target!";
        modeToggle.style.display = "block";
        console.log("Target found!");
      });
      
      // Target lost
      target.addEventListener("targetLost", () => {
        targetDetected = false;
        if (isAnchoredMode) {
          statusEl.innerHTML = "Status: <strong style='color: #fb923c'>Lost</strong>";
          hintEl.innerText = "Point camera at target image";
          modeToggle.style.display = "none";
        }
        console.log("Target lost");
      });
      
      // Mode toggle
      modeToggle.addEventListener("click", () => {
        isAnchoredMode = !isAnchoredMode;
        
        if (isAnchoredMode) {
          // Switch to anchored mode
          freeViewContainer.classList.remove('active');
          blurOverlay.classList.remove('active');
          modeToggle.textContent = "Switch to Free View";
          modeText.textContent = "Anchored Mode";
          hintEl.innerText = "Skull anchored to target!";
          controlsHint.classList.remove('show');
          
          if (!targetDetected) {
            modeToggle.style.display = "none";
          }
        } else {
          // Switch to free view mode
          freeViewContainer.classList.add('active');
          blurOverlay.classList.add('active');
          modeToggle.textContent = "Switch to Anchored";
          modeText.textContent = "Free View Mode";
          hintEl.innerText = "Interact with the skull!";
          controlsHint.classList.add('show');
          
          // Resize Three.js renderer
          setTimeout(() => {
            onWindowResize();
            controlsHint.classList.remove('show');
          }, 100);
        }
      });
      
      // Touch controls for free view
      freeViewCanvas.addEventListener('touchstart', (e) => {
        if (e.touches.length === 1) {
          touchStartX = e.touches[0].clientX;
          touchStartY = e.touches[0].clientY;
        } else if (e.touches.length === 2) {
          const dx = e.touches[0].clientX - e.touches[1].clientX;
          const dy = e.touches[0].clientY - e.touches[1].clientY;
          pinchStartDistance = Math.sqrt(dx * dx + dy * dy);
        }
        e.preventDefault();
      });
      
      freeViewCanvas.addEventListener('touchmove', (e) => {
        if (!skullMesh) return;
        
        if (e.touches.length === 1) {
          // Rotation
          const deltaX = e.touches[0].clientX - touchStartX;
          const deltaY = e.touches[0].clientY - touchStartY;
          
          currentRotationY += deltaX * 0.01;
          currentRotationX -= deltaY * 0.01;
          
          skullMesh.rotation.set(currentRotationX, currentRotationY, 0);
          
          touchStartX = e.touches[0].clientX;
          touchStartY = e.touches[0].clientY;
        } else if (e.touches.length === 2) {
          // Pinch to scale
          const dx = e.touches[0].clientX - e.touches[1].clientX;
          const dy = e.touches[0].clientY - e.touches[1].clientY;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          const scaleDelta = (distance - pinchStartDistance) * 0.002;
          currentScale = Math.max(0.3, Math.min(3, currentScale + scaleDelta));
          
          skullMesh.scale.set(currentScale, currentScale, currentScale);
          
          pinchStartDistance = distance;
        }
        e.preventDefault();
      });
      
      // Mouse controls for desktop testing
      let isMouseDown = false;
      let mouseStartX = 0;
      let mouseStartY = 0;
      
      freeViewCanvas.addEventListener('mousedown', (e) => {
        isMouseDown = true;
        mouseStartX = e.clientX;
        mouseStartY = e.clientY;
      });
      
      window.addEventListener('mousemove', (e) => {
        if (isMouseDown && !isAnchoredMode && skullMesh) {
          const deltaX = e.clientX - mouseStartX;
          const deltaY = e.clientY - mouseStartY;
          
          currentRotationY += deltaX * 0.01;
          currentRotationX -= deltaY * 0.01;
          
          skullMesh.rotation.set(currentRotationX, currentRotationY, 0);
          
          mouseStartX = e.clientX;
          mouseStartY = e.clientY;
        }
      });
      
      window.addEventListener('mouseup', () => {
        isMouseDown = false;
      });
      
      // Mouse wheel for scale (desktop testing)
      freeViewCanvas.addEventListener('wheel', (e) => {
        if (skullMesh) {
          currentScale = Math.max(0.3, Math.min(3, currentScale - e.deltaY * 0.001));
          skullMesh.scale.set(currentScale, currentScale, currentScale);
        }
        e.preventDefault();
      });
    </script>
  </body>
</html>